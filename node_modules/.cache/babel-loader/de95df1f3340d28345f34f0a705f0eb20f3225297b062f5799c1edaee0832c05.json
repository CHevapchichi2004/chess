{"ast":null,"code":"export class Cell {\n  constructor(board, x, y, color, figure) {\n    this.x = void 0;\n    this.y = void 0;\n    this.color = void 0;\n    this.figure = void 0;\n    this.board = void 0;\n    this.available = void 0;\n    this.id = void 0;\n    this.x = x;\n    this.y = y;\n    this.board = board;\n    this.color = color;\n    this.figure = figure;\n    this.available = false;\n    this.id = Math.random();\n  }\n  isEmpty() {\n    return this.figure == null;\n  }\n  isEnemy(target) {\n    if (target.figure) {\n      var _this$figure;\n      return target.figure.color !== ((_this$figure = this.figure) === null || _this$figure === void 0 ? void 0 : _this$figure.color);\n    }\n    return false;\n  }\n  setFigure(figure) {\n    this.figure = figure;\n    this.figure.cell = this;\n  }\n  isEmptyVertival(target) {\n    if (target.x !== this.x) {\n      return false;\n    }\n    const min = Math.min(this.y, target.y);\n    const max = Math.max(this.y, target.y);\n    for (let y = min + 1; y < max; y++) {\n      if (!this.board.getCell(this.x, y).isEmpty()) {\n        return false;\n      }\n    }\n    return true;\n  }\n  isEmptyHorizontal(target) {\n    if (target.y !== this.y) {\n      return false;\n    }\n    const min = Math.min(this.x, target.x);\n    const max = Math.max(this.x, target.x);\n    for (let x = min + 1; x < max; x++) {\n      if (!this.board.getCell(x, this.y).isEmpty()) {\n        return false;\n      }\n    }\n    return true;\n  }\n  isEmptyDiagonal(target) {\n    const absX = Math.abs(target.x - this.x);\n    const absY = Math.abs(target.y - this.y);\n    if (absY !== absX) {\n      return false;\n    }\n    const dy = this.y < target.y ? 1 : -1;\n    const dx = this.x < target.x ? 1 : -1;\n    for (let i = 1; i < absY; i++) {\n      if (!this.board.getCell(this.x + dx * i, this.y + dy * i).isEmpty()) {\n        return false;\n      }\n    }\n    return true;\n  }\n  moveFigure(target) {\n    if (this.figure && this.figure.canMove(target)) {\n      this.figure.moveFigure(target);\n      target.setFigure(this.figure);\n      target.figure = this.figure;\n      this.figure = null;\n    }\n  }\n}","map":{"version":3,"names":["Cell","constructor","board","x","y","color","figure","available","id","Math","random","isEmpty","isEnemy","target","_this$figure","setFigure","cell","isEmptyVertival","min","max","getCell","isEmptyHorizontal","isEmptyDiagonal","absX","abs","absY","dy","dx","i","moveFigure","canMove"],"sources":["D:/chess-ts/chess-ts/src/models/Cell.ts"],"sourcesContent":["import { Board } from \"./Board\";\r\nimport { colors } from \"./Colors\";\r\nimport { Figure } from \"./figures/Figure\";\r\n\r\nexport class Cell {\r\n\treadonly x: number;\r\n\treadonly y: number;\r\n\treadonly color: colors;\r\n\tfigure: Figure | null;\r\n\tboard: Board;\r\n\tavailable: boolean;\r\n\tid: number;\r\n\r\n\tconstructor(\r\n\t\tboard: Board,\r\n\t\tx: number,\r\n\t\ty: number,\r\n\t\tcolor: colors,\r\n\t\tfigure: Figure | null\r\n\t) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.board = board;\r\n\t\tthis.color = color;\r\n\t\tthis.figure = figure;\r\n\t\tthis.available = false;\r\n\t\tthis.id = Math.random();\r\n\t}\r\n\r\n\tpublic isEmpty(): boolean {\r\n\t\treturn this.figure == null;\r\n\t}\r\n\r\n\tpublic isEnemy(target: Cell): boolean {\r\n\t\tif (target.figure) {\r\n\t\t\treturn target.figure.color !== this.figure?.color;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpublic setFigure(figure: Figure) {\r\n\t\tthis.figure = figure;\r\n\t\tthis.figure.cell = this;\r\n\t}\r\n\r\n\tpublic isEmptyVertival(target: Cell): boolean {\r\n\t\tif (target.x !== this.x) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tconst min = Math.min(this.y, target.y);\r\n\t\tconst max = Math.max(this.y, target.y);\r\n\t\tfor (let y = min + 1; y < max; y++) {\r\n\t\t\tif (!this.board.getCell(this.x, y).isEmpty()) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic isEmptyHorizontal(target: Cell): boolean {\r\n\t\tif (target.y !== this.y) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tconst min = Math.min(this.x, target.x);\r\n\t\tconst max = Math.max(this.x, target.x);\r\n\t\tfor (let x = min + 1; x < max; x++) {\r\n\t\t\tif (!this.board.getCell(x, this.y).isEmpty()) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic isEmptyDiagonal(target: Cell): boolean {\r\n\t\tconst absX = Math.abs(target.x - this.x);\r\n\t\tconst absY = Math.abs(target.y - this.y);\r\n\t\tif (absY !== absX) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst dy = this.y < target.y ? 1 : -1;\r\n\t\tconst dx = this.x < target.x ? 1 : -1;\r\n\r\n\t\tfor (let i = 1; i < absY; i++) {\r\n\t\t\tif (!this.board.getCell(this.x + dx * i, this.y + dy * i).isEmpty()) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic moveFigure(target: Cell) {\r\n\t\tif (this.figure && this.figure.canMove(target)) {\r\n\t\t\tthis.figure.moveFigure(target);\r\n\t\t\ttarget.setFigure(this.figure);\r\n\t\t\ttarget.figure = this.figure;\r\n\t\t\tthis.figure = null;\r\n\t\t}\r\n\t}\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}